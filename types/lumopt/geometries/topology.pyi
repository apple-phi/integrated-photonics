from _typeshed import Incomplete
from lumopt.geometries.geometry import Geometry as Geometry
from lumopt.lumerical_methods.lumerical_scripts import get_eps_from_sim as get_eps_from_sim, set_spatial_interp as set_spatial_interp
from lumopt.utilities.materials import Material as Material
from scipy.interpolate import RegularGridInterpolator as RegularGridInterpolator
from scipy.signal import convolve2d as convolve2d

eps0: Incomplete

class TopologyOptimization2DParameters(Geometry):
    last_params: Incomplete
    eps_min: Incomplete
    eps_max: Incomplete
    eps: Incomplete
    x: Incomplete
    y: Incomplete
    z: Incomplete
    bounds: Incomplete
    filter_R: Incomplete
    eta: Incomplete
    eta_d: Incomplete
    eta_e: Incomplete
    g_s_hist: Incomplete
    g_v_hist: Incomplete
    beta: Incomplete
    dx: Incomplete
    dy: Incomplete
    dz: Incomplete
    depth: Incomplete
    beta_factor: float
    discreteness: int
    penalty_scaling_beta_threshold: Incomplete
    penalty_scaling_factor_max: float
    penalty_scaling_factor: Incomplete
    symmetry_x: bool
    symmetry_y: bool
    unfold_symmetry: Incomplete
    def __init__(self, params, eps_min, eps_max, x, y, z, filter_R, eta, beta, eps: Incomplete | None = None, min_feature_size: int = 0) -> None: ...
    def get_delta_eta_from_length(self, target_length, filter_R): ...
    def use_interpolation(self): ...
    def check_license_requirements(self, sim): ...
    def calc_penalty_term(self, sim, params): ...
    def calc_penalty_gradient(self, sim, params): ...
    def calc_discreteness(self): ...
    def progress_continuation(self): ...
    def to_file(self, filename) -> None: ...
    def calc_params_from_eps(self, eps): ...
    def get_params_from_eps(self, eps): ...
    def set_params_from_eps(self, eps) -> None: ...
    def check_param_count_matches_bounds(self, param) -> None: ...
    def check_param_count_matches_sim_eps(self, params, sim) -> None: ...
    def extract_parameters_from_simulation(self, sim) -> None: ...
    def get_eps_from_params(self, sim, params): ...
    opt: Incomplete
    def initialize(self, wavelengths, opt) -> None: ...
    def update_geometry(self, params, sim) -> None: ...
    def unfold_symmetry_if_applicable(self, rho): ...
    def get_current_params_inshape(self, unfold_symmetry: bool = False): ...
    def get_current_params(self): ...
    def plot(self, ax_eps): ...
    def write_status(self, f) -> None: ...

class TopologyOptimization2D(TopologyOptimization2DParameters):
    self_update: bool
    def __init__(self, params, eps_min, eps_max, x, y, z: int = 0, filter_R: float = 2e-07, eta: float = 0.5, beta: int = 1, eps: Incomplete | None = None, min_feature_size: int = 0) -> None: ...
    @classmethod
    def from_file(cls, filename, z: int = 0, filter_R: float = 2e-07, eta: float = 0.5, beta: Incomplete | None = None): ...
    def get_params_from_eps(self, eps): ...
    def calculate_gradients_on_cad(self, sim, forward_fields, adjoint_fields, wl_scaling_factor): ...
    def calculate_gradients(self, gradient_fields, sim): ...
    def add_geo(self, sim, params: Incomplete | None = None, only_update: bool = False) -> None: ...

class TopologyOptimization3DLayered(TopologyOptimization2DParameters):
    self_update: bool
    def __init__(self, params, eps_min, eps_max, x, y, z, filter_R: float = 2e-07, eta: float = 0.5, beta: int = 1, min_feature_size: int = 0) -> None: ...
    @classmethod
    def from_file(cls, filename, filter_R, eta: float = 0.5, beta: Incomplete | None = None): ...
    def to_file(self, filename) -> None: ...
    def get_params_from_eps(self, eps) -> None: ...
    def calculate_gradients(self, gradient_fields, sim): ...
    def calculate_gradients_on_cad(self, sim, forward_fields, adjoint_fields, wl_scaling_factor): ...
    def add_geo(self, sim, params: Incomplete | None = None, only_update: bool = False) -> None: ...
